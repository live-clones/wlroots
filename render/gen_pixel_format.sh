#!/bin/sh -eu
#
# usage: gen_pixel_format.sh pixel_format_table.c

KDFS=${KDFS:-kdfs}

output_file="$1"

gen_info() {
	kdfs show --json 'DRM_FORMAT_*' | jq -r '
		to_entries[]
		| select((.value.bytes_plane | length) == 1)
		|
			"	{\n" +
			"		.drm_format = \(.key),\n" +
			"		.bytes_per_block = \(.value.bytes_plane[0]),\n" +
			"		.block_width = \(.value.texel_block_dimension[0]),\n" +
			"		.block_height = \(.value.texel_block_dimension[1]),\n" +
			"	},"
	'
}

gen_opaque() {
	kdfs show --json 'DRM_FORMAT_*' | jq -r '
		to_entries[]
		| select(any(.value.sample_info[]; .channel == "a") | not)
		| "	case \(.key):"
	'
}

gen_ycbcr() {
	kdfs show --json 'DRM_FORMAT_*' | jq -r '
		to_entries[]
		| select(.value.color_model == "yuvsda")
		| "	case \(.key):"
	'
}

cat >"$output_file" << EOF
// Generated by gen_pixel_formats.sh - DO NOT EDIT

#include <drm_fourcc.h>
#include "render/pixel_format.h"

const struct wlr_pixel_format_info pixel_format_info[] = {
$(gen_info)
};

const size_t pixel_format_info_len = sizeof(pixel_format_info) / sizeof(pixel_format_info[0]);

bool pixel_format_is_opaque(uint32_t format) {
	switch (format) {
$(gen_opaque)
		return true;
	default:
		return false;
	}
}

bool pixel_format_is_ycbcr(uint32_t format) {
	switch (format) {
$(gen_ycbcr)
		return true;
	default:
		return false;
	}
}
EOF
